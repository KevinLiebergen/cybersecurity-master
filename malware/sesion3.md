# Tema 3: Obtención de muestras

(Tema 1: Introducción)
(Tema 2: Entorno de trabajo)

## Repositorios limpios

* https://github.com/ytisf/theZoo
* https://bazaar.abuse.ch

## Repositorios alternativos

* https://vx-underground.org
* https://virusshare.com
* https://vxvault.net

* https://teatv.net/ (?)
## Descarga de fuentes

* https://www.virustotal.com
* https://any.run
* https://koodous.com

* https://abuse.ch
* https://feodotracker


## Gestión de artefactos

* UID (Identificador único de usuario)

* Vamos a identificar malware con SHA256, pero lo queremos meter en el sistema de archivos de nuestro archivo y  lo mejor se queja, por ello también utilizaremos SHA1.
  * SHA256 más seguro

* __SSDEEP__: Hash no criptográfico, pero no protegen la CID, un pequeño cambio en el fichero no va a desvariar todo el hash, si no a una porción del hash
  * Hashes diferenciales

* Vamos a guardar en un zip el malware con contraseña
  * No es por medida de control de acceso
  * Sino para cifrar el contenido del zip, para que esté __ofuscado__ y Windows Defender, el correo electrónico, etc no se queje.
* __Cambiar extensión a .malware__ para no ejecutarlo


* Guardar información relacionado con el UID que le hemos dado con sun informe
* Si hay nombre público también lo guardamos
* UID porque puede haber varias muestras del mismo malware


## theJungle

* Cuenta grupal clase en gitlab
* Estructura del repositorio

* `samples/`  
  * UID
    * [sha1]/
      * [sha1].sha1
      * [sha1].sha256
      * [sha1].ssdeep
      * [sha1].password -> "infected"
      * [sha1].zip
        * [sha1].malware

* `info/`
  * UID/
    * README.md -> info del malware
    * names.txt -> Lista de nombres conocidos
    * rules/ -> Reglas de deteccion
* `malware/` (Meter los malware)


* Al malware, sacamos el hash, después de poner como nombre el hash lo zipeamos con contraseña, lo borramos del sitio de antes y lo copiamos en carpeta `samples` el .sha1, el .sha256 y el .zip




### Generación uuid en python

```python
import uuid

id = str(uuid.uuid4())
```

### Hashes del binario

```python
import hashlib

bin_sha1 = hashlib.sha1(binary).hexdigest()
bin_sha256 = hashlib.sha256(binary).hexdigest()
```

O también:

```python
import hashlib
with open('Johnnie.exe', 'rb') as f:
    bin = f.read()

hashlib.md5(bin).hexdigest()
hashlib.sha1(bin).hexdigest()
```


### Hashes diferenciales - ssdeep

```python
import ssdeep

bin_ssdeep = ssdeep.hash(binary)
bin_ssdeep = ssdeep.hash('[hash].malware')
```

Es lo mismo que

`$ ssdeep [hash].malware`


### Otros hashes

`get_imphash()` realiza el hash de las funciones importadas de dos archivos de tal forma que si alguno se le añade contenido basura para que lo hashes difieran, no se engañe a los antivirus y el resultado de los dos hashes generados sean el mismo (al tener las mismas funciones importadas).


```python
import pefile # Solo valen para PEs
import sys

pe = pefile.PE(sys.argv[1])
print(pe.get_imphash())

```


### Búsqueda de similares

```python
import ssdeep

ssdeep.compare(hash1, hash2) # return value [0,100]
```

### Almacenamiento cifrado

```python
import pyminzip

pyminzip.compress("[SHA1].malware", "/", "[SHA1].zip", "infected", 0)
```